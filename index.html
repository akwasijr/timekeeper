<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Spotify Playlist Maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the body and root container, mimicking Spotify's dark theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212; /* Dark Spotify-like background */
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        #app-container {
            width: 100%;
            max-width: 900px;
            background-color: #1a1a1a;
            border-radius: 15px;
            box-shadow: 0 4px 60px rgba(0, 0, 0, 0.5);
            padding: 30px;
            box-sizing: border-box;
        }
        /* Custom scrollbar for better aesthetics, especially in song preview list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #282828;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #535353;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #737373;
        }
        /* Basic animation for message box fade-in */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out;
        }
        /* Hidden class for toggling views */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <h1 class="text-4xl font-bold text-center text-[#1DB954] mb-8">
            AI Spotify Playlist Maker
        </h1>

        <div id="message-box-container"></div>

        <div id="spotify-login-view" class="text-center">
            <p class="mb-6 text-lg text-gray-300">
                Please log in with your Spotify account to create AI-powered playlists.
            </p>
            <button id="login-spotify-btn" class="bg-[#1DB954] text-white font-semibold py-3 px-8 rounded-full shadow-lg hover:bg-[#1ed760] transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-[#1DB954] focus:ring-opacity-50">
                Login with Spotify
            </button>
        </div>

        <div id="authenticated-content" class="hidden">
            <div class="text-center mb-6">
                <p class="text-lg text-gray-300">
                    Logged in as: <span id="spotify-display-name" class="font-semibold text-[#1DB954]"></span>
                </p>
                <p id="firebase-user-id" class="text-sm text-gray-500 mt-1 hidden"></p>
            </div>

            <div id="input-view" class="space-y-6">
                <div>
                    <label for="playlistDescription" class="block text-lg font-medium text-gray-300 mb-2">
                        Describe the playlist you want to create:
                    </label>
                    <textarea
                        id="playlistDescription"
                        rows="4"
                        placeholder="e.g., Chill indie songs for a rainy Sunday afternoon, Upbeat workout hits from the 90s, Relaxing jazz for studying"
                        class="w-full p-3 bg-[#282828] border border-[#333] rounded-md text-white placeholder-gray-500 focus:ring-2 focus:ring-[#1DB954] focus:border-transparent transition duration-200 resize-y"
                    ></textarea>
                </div>
                <button id="get-suggestions-btn" class="w-full bg-[#1DB954] text-white font-semibold py-3 px-6 rounded-full shadow-lg hover:bg-[#1ed760] transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-[#1DB954] focus:ring-opacity-50">
                    Get AI Song Suggestions
                </button>
            </div>

            <div id="preview-view" class="space-y-6 hidden">
                <h2 class="text-3xl font-semibold text-white mb-4 text-center">
                    Suggested Playlist: <span id="preview-playlist-title" class="text-[#1DB954]"></span>
                </h2>
                <div id="parsed-songs-list" class="space-y-4 max-h-96 overflow-y-auto pr-2 custom-scrollbar">
                    </div>
                <div class="flex justify-between gap-4 mt-6 flex-wrap">
                    <button id="back-to-description-btn" class="flex-1 min-w-[48%] bg-gray-600 text-white font-semibold py-3 px-6 rounded-full shadow-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-600 focus:ring-opacity-50">
                        Change Description
                    </button>
                    <button id="create-playlist-btn" class="flex-1 min-w-[48%] bg-[#1DB954] text-white font-semibold py-3 px-6 rounded-full shadow-lg hover:bg-[#1ed760] transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-[#1DB954] focus:ring-opacity-50">
                        Create Playlist
                    </button>
                </div>
            </div>

            <div id="created-view" class="text-center space-y-6 hidden">
                <h2 class="text-3xl font-bold text-[#1DB954] mb-4">
                    Playlist Created Successfully!
                </h2>
                <p class="text-lg text-gray-300">
                    Your playlist "<span id="created-playlist-title" class="font-semibold"></span>" has been added to Spotify.
                </p>
                <div id="ai-playlist-summary-container" class="mt-4 p-4 bg-[#282828] rounded-lg border border-[#333] hidden">
                    <p class="text-gray-300 font-semibold mb-2">AI-Generated Summary ✨</p>
                    <p id="ai-playlist-summary" class="text-gray-400 text-sm"></p>
                </div>
                <button id="generate-summary-btn" class="mt-4 bg-purple-600 text-white font-semibold py-2 px-6 rounded-full shadow-lg hover:bg-purple-700 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-purple-600 focus:ring-opacity-50">
                    Generate Playlist Summary ✨
                </button>
                <a id="open-playlist-url" href="#" target="_blank" rel="noopener noreferrer" class="inline-block bg-[#1DB954] text-white font-semibold py-3 px-8 rounded-full shadow-lg hover:bg-[#1ed760] transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-[#1DB954] focus:ring-opacity-50 mt-4">
                    Open Playlist on Spotify
                </a>
                <button id="create-another-playlist-btn" class="block mx-auto mt-8 bg-gray-600 text-white font-semibold py-3 px-8 rounded-full shadow-lg hover:bg-gray-700 transition duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-600 focus:ring-opacity-50">
                    Create Another Playlist
                </button>
            </div>

            <div id="auth-pending-view" class="text-center space-y-4 hidden">
                <svg class="animate-spin h-10 w-10 text-[#1DB954] mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="text-lg text-gray-300">
                    Finalizing Spotify login...
                </p>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase instances
        window.firebaseAppInstance = null;
        window.firebaseDbInstance = null;
        window.firebaseAuthInstance = null;
        window.firebaseUserId = null;
        window.isFirebaseAuthReady = false;

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // Initialize Firebase
        if (Object.keys(firebaseConfig).length > 0) {
            window.firebaseAppInstance = initializeApp(firebaseConfig);
            window.firebaseDbInstance = getFirestore(window.firebaseAppInstance);
            window.firebaseAuthInstance = getAuth(window.firebaseAppInstance);

            onAuthStateChanged(window.firebaseAuthInstance, async (user) => {
                if (!user) {
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(window.firebaseAuthInstance, __initial_auth_token);
                            window.firebaseUserId = window.firebaseAuthInstance.currentUser?.uid;
                            console.log("Firebase authenticated with custom token:", window.firebaseUserId);
                        } else {
                            await signInAnonymously(window.firebaseAuthInstance);
                            window.firebaseUserId = window.firebaseAuthInstance.currentUser?.uid;
                            console.log("Firebase signed in anonymously:", window.firebaseUserId);
                        }
                    } catch (error) {
                        console.error("Firebase authentication error:", error);
                    }
                } else {
                    window.firebaseUserId = user.uid;
                    console.log("Firebase user already signed in:", user.uid);
                }
                window.isFirebaseAuthReady = true;
                // Update Firebase User ID display once ready
                const firebaseUserIdEl = document.getElementById('firebase-user-id');
                if (firebaseUserIdEl) {
                    firebaseUserIdEl.textContent = `Firebase User ID: ${window.firebaseUserId}`;
                    firebaseUserIdEl.classList.remove('hidden');
                }
            });
        } else {
            console.warn("Firebase configuration not provided. Firebase services will not be available.");
            window.isFirebaseAuthReady = true; // Mark ready even if not configured
        }
    </script>

    <script>
        // --- Global State Variables ---
        let currentView = 'input'; // 'input', 'preview', 'created', 'auth_pending'
        let playlistDescription = ''; // New: stores user's playlist description
        let playlistTitle = ''; // Suggested by AI
        let parsedSongs = []; // [{ artist: "...", title: "...", spotifyResults: [], selectedTrack: {} }]
        let isLoading = false;
        let spotifyProfile = null;
        let newPlaylistUrl = '';
        let audioPlayer = new Audio();
        let playingTrackId = null;
        let aiPlaylistSummary = ''; // New: stores AI-generated playlist summary

        // --- DOM Elements ---
        const appContainer = document.getElementById('app-container');
        const messageBoxContainer = document.getElementById('message-box-container');

        const spotifyLoginView = document.getElementById('spotify-login-view');
        const loginSpotifyBtn = document.getElementById('login-spotify-btn');

        const authenticatedContent = document.getElementById('authenticated-content');
        const spotifyDisplayNameEl = document.getElementById('spotify-display-name');
        const firebaseUserIdEl = document.getElementById('firebase-user-id');

        const inputView = document.getElementById('input-view');
        const playlistDescriptionTextarea = document.getElementById('playlistDescription'); // New: description input
        const getSuggestionsBtn = document.getElementById('get-suggestions-btn'); // Renamed button

        const previewView = document.getElementById('preview-view');
        const previewPlaylistTitleEl = document.getElementById('preview-playlist-title');
        const parsedSongsList = document.getElementById('parsed-songs-list');
        const backToDescriptionBtn = document.getElementById('back-to-description-btn'); // Renamed button
        const createPlaylistBtn = document.getElementById('create-playlist-btn');

        const createdView = document.getElementById('created-view');
        const createdPlaylistTitleEl = document.getElementById('created-playlist-title');
        const aiPlaylistSummaryContainer = document.getElementById('ai-playlist-summary-container'); // New
        const aiPlaylistSummaryEl = document.getElementById('ai-playlist-summary'); // New
        const generateSummaryBtn = document.getElementById('generate-summary-btn'); // New
        const openPlaylistUrlLink = document.getElementById('open-playlist-url');
        const createAnotherPlaylistBtn = document.getElementById('create-another-playlist-btn');

        const authPendingView = document.getElementById('auth-pending-view');

        // --- Helper Functions ---

        /**
         * Renders the message box with a given message and type.
         * @param {string} message The message to display.
         * @param {'info'|'success'|'error'} type The type of message (influences color).
         */
        function showMessageBox(message, type = 'info') {
            let bgColor = 'bg-blue-600';
            if (type === 'error') bgColor = 'bg-red-600';
            if (type === 'success') bgColor = 'bg-green-600';

            messageBoxContainer.innerHTML = `
                <div class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
                    <div class="p-6 rounded-lg shadow-xl ${bgColor} max-w-sm w-full text-center animate-fade-in">
                        <p class="text-lg font-semibold mb-4 text-white">${message}</p>
                        <button id="close-message-box-btn" class="mt-4 px-6 py-2 bg-white text-gray-900 rounded-md hover:bg-gray-200 transition duration-200 shadow-md focus:outline-none focus:ring-2 focus:ring-white">
                            Close
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('close-message-box-btn').addEventListener('click', () => {
                messageBoxContainer.innerHTML = ''; // Clear message box
            });
        }

        /**
         * Updates the UI based on the current `currentView` state.
         */
        function updateView() {
            // Hide all views first
            spotifyLoginView.classList.add('hidden');
            authenticatedContent.classList.add('hidden');
            inputView.classList.add('hidden');
            previewView.classList.add('hidden');
            createdView.classList.add('hidden');
            authPendingView.classList.add('hidden');

            if (!spotifyProfile) {
                spotifyLoginView.classList.remove('hidden');
                return;
            }

            authenticatedContent.classList.remove('hidden');
            spotifyDisplayNameEl.textContent = spotifyProfile.display_name;

            // Display Firebase User ID if ready
            if (window.isFirebaseAuthReady && window.firebaseUserId) {
                firebaseUserIdEl.textContent = `Firebase User ID: ${window.firebaseUserId}`;
                firebaseUserIdEl.classList.remove('hidden');
            } else {
                firebaseUserIdEl.classList.add('hidden');
            }

            switch (currentView) {
                case 'input':
                    inputView.classList.remove('hidden');
                    playlistDescriptionTextarea.value = playlistDescription; // Set description value
                    updateLoadingState(getSuggestionsBtn, 'Get AI Song Suggestions');
                    break;
                case 'preview':
                    previewView.classList.remove('hidden');
                    previewPlaylistTitleEl.textContent = playlistTitle;
                    renderParsedSongsList();
                    updateLoadingState(createPlaylistBtn, 'Create Playlist');
                    // Disable create button if no selected tracks
                    createPlaylistBtn.disabled = parsedSongs.filter(s => s.selectedTrack).length === 0 || isLoading;
                    break;
                case 'created':
                    createdView.classList.remove('hidden');
                    createdPlaylistTitleEl.textContent = playlistTitle;
                    openPlaylistUrlLink.href = newPlaylistUrl;
                    // Reset summary section visibility
                    aiPlaylistSummaryContainer.classList.add('hidden');
                    aiPlaylistSummaryEl.textContent = '';
                    updateLoadingState(generateSummaryBtn, 'Generate Playlist Summary ✨');
                    break;
                case 'auth_pending':
                    authPendingView.classList.remove('hidden');
                    break;
            }
        }

        /**
         * Updates the loading state of a button.
         * @param {HTMLElement} buttonElement The button to update.
         * @param {string} originalText The original text of the button.
         * @param {string} loadingText The text to show when loading.
         */
        function updateLoadingState(buttonElement, originalText, loadingText = '') {
            if (isLoading) {
                buttonElement.disabled = true;
                buttonElement.innerHTML = `
                    <span class="flex items-center justify-center">
                        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        ${loadingText || originalText.replace('Get AI Song Suggestions', 'Getting Suggestions').replace('Create Playlist', 'Creating Playlist').replace('Generate Playlist Summary', 'Generating Summary')}...
                    </span>
                `;
            } else {
                buttonElement.disabled = false;
                buttonElement.innerHTML = originalText;
            }
        }


        /**
         * Renders the list of parsed songs in the preview view.
         */
        function renderParsedSongsList() {
            parsedSongsList.innerHTML = '';
            if (parsedSongs.length === 0) {
                parsedSongsList.innerHTML = '<p class="text-gray-400 text-center">No songs suggested or selected. Go back to change description.</p>';
                return;
            }

            parsedSongs.forEach((song, index) => {
                const songItem = document.createElement('div');
                songItem.className = 'bg-[#282828] p-4 rounded-lg shadow flex flex-col sm:flex-row items-center justify-between gap-4 border border-[#333]';
                songItem.innerHTML = `
                    <div class="flex-grow text-center sm:text-left">
                        <p class="text-xl font-bold text-white">${song.title}</p>
                        <p class="text-gray-400">${song.artist || 'Unknown Artist'}</p>
                        ${song.selectedTrack ? `
                            <p class="text-sm text-gray-500 mt-1">
                                Selected: ${song.selectedTrack.name} by ${song.selectedTrack.artists.map(a => a.name).join(', ')}
                            </p>
                        ` : ''}
                    </div>
                    <div class="flex flex-col sm:flex-row items-center gap-2">
                        ${song.spotifyResults.length > 0 ? `
                            <select class="p-2 bg-[#333] border border-[#444] rounded-md text-white focus:ring-2 focus:ring-[#1DB954] focus:border-transparent transition duration-200" data-index="${index}">
                                ${song.spotifyResults.map(track => `
                                    <option value="${track.id}" ${song.selectedTrack && song.selectedTrack.id === track.id ? 'selected' : ''}>
                                        ${track.name} - ${track.artists.map(a => a.name).join(', ')}
                                    </option>
                                `).join('')}
                            </select>
                        ` : `
                            <span class="text-red-400 text-sm">No Spotify results found.</span>
                        `}
                        ${song.selectedTrack && song.selectedTrack.preview_url ? `
                            <button class="play-preview-btn p-2 rounded-full ${playingTrackId === song.selectedTrack.id ? 'bg-red-500 hover:bg-red-600' : 'bg-blue-500 hover:bg-blue-600'} text-white transition duration-200 flex items-center justify-center" data-preview-url="${song.selectedTrack.preview_url}" data-track-id="${song.selectedTrack.id}" title="${playingTrackId === song.selectedTrack.id ? "Stop Preview" : "Play Preview"}">
                                ${playingTrackId === song.selectedTrack.id ? `
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                                        <path fill-rule="evenodd" d="M6.75 5.25a.75.75 0 01.75-.75H9a.75.75 0 01.75.75v13.5a.75.75 0 01-.75.75H7.5a.75.75 0 01-.75-.75V5.25zm7.5 0a.75.75 0 01.75-.75h1.5a.75.75 0 01.75.75v13.5a.75.75 0 01-.75.75h-1.5a.75.75 0 01-.75-.75V5.25z" clip-rule="evenodd" />
                                    </svg>
                                ` : `
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                                        <path fill-rule="evenodd" d="M4.5 5.653c0-1.426 1.798-2.324 3.067-1.638l11.54 6.348c1.352.742 1.352 2.53 0 3.272L7.567 21.983a2.25 2.25 0 01-3.067-1.638V5.653z" clip-rule="evenodd" />
                                    </svg>
                                `}
                            </button>
                        ` : ''}
                        <button class="remove-song-btn p-2 rounded-full bg-red-500 text-white hover:bg-red-600 transition duration-200 flex items-center justify-center" data-index="${index}" title="Remove Song">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                                <path fill-rule="evenodd" d="M16.5 4.478v.227a48.816 48.816 0 013.878.512.75.75 0 11-.233 1.488l-.M6.75 1.5A.75.75 0 017.5 0h9a.75.75 0 01.75.75V3a.75.75 0 01-.75.75h-.22754a.75.75 0 01-.75-.75V1.5h-.001a.75.75 0 01-1.5 0v.001h-2a.75.75 0 01-1.5 0h-2a.75.75 0 01-1.5 0h-2.001a.75.75 0 01-1.5 0h-2.22754V3.75c0-.414-.336-.75-.75-.75zM12 2.25a.75.75 0 01.75.75v.001h-1.5V3a.75.75 0 01.75-.75zm4.5 3a.75.75 0 01.75-.75h1.5a.75.75 0 01.75.75v.227a48.816 48.816 0 013.878.512.75.75 0 11-.233 1.488l-9.043 1.432-1.226 5.864-1.485.495a.75.75 0 01-.75-.75v-9a.75.75 0 01.75-.75zm-6.002 0c-.75 0-1.5.75-1.5 1.5v12c0 1.5.75 2.25 1.5 2.25h9c.75 0 1.5-.75 1.5-1.5V6.75c0-.75-.75-1.5-1.5-1.5H6.002z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                `;
                parsedSongsList.appendChild(songItem);
            });

            // Add event listeners after rendering
            parsedSongsList.querySelectorAll('.play-preview-btn').forEach(button => {
                button.addEventListener('click', (event) => {
                    const previewUrl = event.currentTarget.dataset.previewUrl;
                    const trackId = event.currentTarget.dataset.trackId;
                    playPreview(previewUrl, trackId);
                });
            });

            parsedSongsList.querySelectorAll('.remove-song-btn').forEach(button => {
                button.addEventListener('click', (event) => {
                    const index = parseInt(event.currentTarget.dataset.index);
                    handleRemoveSong(index);
                });
            });

            parsedSongsList.querySelectorAll('select').forEach(select => {
                select.addEventListener('change', (event) => {
                    const index = parseInt(event.currentTarget.dataset.index);
                    const selectedTrackId = event.currentTarget.value;
                    const song = parsedSongs[index];
                    const selected = song.spotifyResults.find(t => t.id === selectedTrackId);
                    handleTrackSelection(index, selected);
                });
            });
        }


        // --- Core Application Logic ---

        // Helper function to generate a random string for PKCE
        function generateRandomString(length) {
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            const values = crypto.getRandomValues(new Uint8Array(length));
            return values.map(byte => possible[byte % possible.length]).join('');
        }

        // Helper function to generate PKCE code challenge
        async function sha256(plain) {
            const encoder = new TextEncoder();
            const data = encoder.encode(plain);
            return window.crypto.subtle.digest('SHA-256', data);
        }

        function base64encode(input) {
            return btoa(String.fromCharCode(...new Uint8Array(input)))
                .replace(/=/g, '')
                .replace(/\+/g, '-')
                .replace(/\//g, '_');
        }

        // Spotify Authentication Utility
        const SpotifyAuth = {
            clientId: '11dbe168b3564e6cb3dacfc502915a71',
            // Corrected redirectUri: Spotify's authorization server does not include the hash part.
            // Ensure this EXACTLY matches the Redirect URI set in your Spotify Developer Dashboard for your application.
            redirectUri: 'https://playlister-dct.pages.dev/',
            scope: 'user-read-private user-read-email playlist-modify-public playlist-modify-private',

            /**
             * Redirects the user to Spotify's authorization page using PKCE.
             */
            async redirectToAuthCodeFlow() {
                const verifier = generateRandomString(128);
                const challenge = base64encode(await sha256(verifier));

                localStorage.setItem('spotify_code_verifier', verifier);

                const params = new URLSearchParams();
                params.append('client_id', this.clientId);
                params.append('response_type', 'code');
                params.append('redirect_uri', this.redirectUri);
                params.append('scope', this.scope);
                params.append('code_challenge_method', 'S256');
                params.append('code_challenge', challenge);

                window.location.href = `https://accounts.spotify.com/authorize?${params.toString()}`;
            },

            /**
             * Exchanges the authorization code for an access token.
             * @param {string} code The authorization code received from Spotify.
             * @returns {Promise<string>} The Spotify access token.
             */
            async getAccessToken(code) {
                const verifier = localStorage.getItem('spotify_code_verifier');

                const params = new URLSearchParams();
                params.append('client_id', this.clientId);
                params.append('grant_type', 'authorization_code');
                params.append('code', code);
                params.append('redirect_uri', this.redirectUri);
                params.append('code_verifier', verifier);

                const result = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: params.toString(),
                });

                if (!result.ok) {
                    const errorData = await result.json();
                    console.error('Failed to get Spotify access token:', errorData);
                    throw new Error(`Spotify token error: ${errorData.error_description || result.statusText}`);
                }

                const { access_token, expires_in, refresh_token } = await result.json();
                localStorage.setItem('spotify_access_token', access_token);
                localStorage.setItem('spotify_token_expires_at', Date.now() + expires_in * 1000);
                localStorage.setItem('spotify_refresh_token', refresh_token);
                localStorage.removeItem('spotify_code_verifier'); // Clear verifier after use
                return access_token;
            },

            /**
             * Refreshes the Spotify access token using the stored refresh token.
             * @returns {Promise<string|null>} The new access token, or null if refresh fails.
             */
            async refreshAccessToken() {
                const refreshToken = localStorage.getItem('spotify_refresh_token');
                if (!refreshToken) {
                    console.log('No refresh token found. Redirecting to login.');
                    return null;
                }

                const params = new URLSearchParams();
                params.append('grant_type', 'refresh_token');
                params.append('refresh_token', refreshToken);
                params.append('client_id', this.clientId); // Client ID is needed for refresh token flow

                const result = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: params.toString(),
                });

                if (!result.ok) {
                    const errorData = await result.json();
                    console.error('Failed to refresh Spotify access token:', errorData);
                    // If refresh fails, clear tokens and require re-authentication
                    localStorage.removeItem('spotify_access_token');
                    localStorage.removeItem('spotify_token_expires_at');
                    localStorage.removeItem('spotify_refresh_token');
                    return null;
                }

                const { access_token, expires_in } = await result.json();
                localStorage.setItem('spotify_access_token', access_token);
                localStorage.setItem('spotify_token_expires_at', Date.now() + expires_in * 1000);
                return access_token;
            },

            /**
             * Retrieves a valid Spotify access token, refreshing it if necessary.
             * @returns {Promise<string|null>} A valid access token, or null if login is required.
             */
            async getValidAccessToken() {
                let token = localStorage.getItem('spotify_access_token');
                let expiresAt = localStorage.getItem('spotify_token_expires_at');

                if (!token || !expiresAt || Date.now() >= parseInt(expiresAt, 10)) {
                    console.log('Access token expired or not found. Attempting to refresh...');
                    token = await this.refreshAccessToken();
                }
                return token;
            },
        };

        // Spotify API Interaction Utility
        const SpotifyAPI = {
            /**
             * Generic Spotify API call helper.
             * @param {string} url The Spotify API endpoint (e.g., '/me', '/search').
             * @param {string} method HTTP method (GET, POST).
             * @param {object|null} body Request body for POST requests.
             * @returns {Promise<object>} The JSON response from the Spotify API.
             */
            async call(url, method = 'GET', body = null) {
                const token = await SpotifyAuth.getValidAccessToken();
                if (!token) {
                    throw new Error('No valid Spotify access token. Please log in.');
                }

                const headers = {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                };

                const config = {
                    method,
                    headers,
                };

                if (body) {
                    config.body = JSON.stringify(body);
                }

                const response = await fetch(`https://api.spotify.com/v1${url}`, config);

                if (response.status === 401) { // Token expired or invalid
                    // Clear tokens and force re-authentication
                    localStorage.removeItem('spotify_access_token');
                    localStorage.removeItem('spotify_token_expires_at');
                    localStorage.removeItem('spotify_refresh_token');
                    throw new Error('Spotify token expired or invalid. Please re-authenticate.');
                }

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error(`Spotify API error on ${url}:`, errorData);
                    throw new Error(`Spotify API error: ${errorData.error?.message || response.statusText}`);
                }

                return response.json();
            },

            /**
             * Fetches the current user's Spotify profile.
             */
            async getCurrentUserProfile() {
                return this.call('/me');
            },

            /**
             * Searches for tracks on Spotify.
             * @param {string} query The search query (e.g., "Bohemian Rhapsody Queen").
             * @returns {Promise<object>} Search results.
             */
            async searchTracks(query) {
                return this.call(`/search?q=${encodeURIComponent(query)}&type=track&limit=5`);
            },

            /**
             * Creates a new Spotify playlist for the given user.
             * @param {string} userId The Spotify user ID.
             * @param {string} name The name of the playlist.
             * @param {string} description The description of the playlist.
             * @param {boolean} isPublic Whether the playlist is public or private.
             * @returns {Promise<object>} The created playlist object.
             */
            async createPlaylist(userId, name, description = '', isPublic = true) {
                return this.call(`/users/${userId}/playlists`, 'POST', {
                    name,
                    description,
                    public: isPublic,
                });
            },

            /**
             * Adds tracks to an existing Spotify playlist.
             * @param {string} playlistId The ID of the playlist.
             * @param {string[]} uris An array of Spotify track URIs (e.g., ['spotify:track:trackId']).
             * @returns {Promise<object>} Response indicating success.
             */
            async addTracksToPlaylist(playlistId, uris) {
                return this.call(`/playlists/${playlistId}/tracks`, 'POST', {
                    uris,
                });
            },
        };

        // LLM Integration for song parsing and suggestion
        /**
         * Uses Gemini API to generate a playlist title and song suggestions based on a description.
         * @param {string} description A text description of the desired playlist.
         * @returns {Promise<{playlistTitle: string, songs: Array<{artist: string|null, title: string}>}>} An object with suggested title and songs.
         */
        async function getAiSuggestedPlaylist(description) {
            const chatHistory = [];
            const prompt = `Based on the following playlist description, suggest a fitting playlist title (short and creative) and a list of 10-15 song suggestions. For each song, provide the artist and title. Return the response as a JSON object with two keys: 'playlistTitle' (string) and 'songs' (an array of objects, each with 'artist' and 'title' keys). If an artist is not explicitly known, set it to null. Ensure the response is ONLY the JSON object, no additional text or markdown outside it.

            Playlist Description: "${description}"

            Example Output:
            {
              "playlistTitle": "Rainy Day Indie Vibes",
              "songs": [
                { "artist": "Bon Iver", "title": "Flume" },
                { "artist": "Phoebe Bridgers", "title": "Motion Sickness" },
                { "artist": "The xx", "title": "Intro" },
                { "artist": "Fleet Foxes", "title": "Helplessness Blues" },
                { "artist": "Maggie Rogers", "title": "Alaska" },
                { "artist": "Lord Huron", "title": "The Night We Met" },
                { "artist": "Hozier", "title": "Work Song" },
                { "artist": "Local Natives", "title": "When Am I Gonna Lose You" },
                { "artist": "alt-J", "title": "Breezeblocks" },
                { "artist": "Sufjan Stevens", "title": "Mystery of Love" }
              ]
            }`;

            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "playlistTitle": { "type": "STRING" },
                            "songs": {
                                type: "ARRAY",
                                items: {
                                    type: "OBJECT",
                                    properties: {
                                        "artist": { "type": "STRING", "nullable": true },
                                        "title": { "type": "STRING" }
                                    },
                                    "required": ["title"]
                                }
                            }
                        },
                        "required": ["playlistTitle", "songs"]
                    }
                }
            };

            const apiKey = ""; // Canvas will provide this API key at runtime.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    // Log more detailed response info for debugging
                    console.error('Gemini API request failed:', response.status, response.statusText, errorText);
                    throw new Error(`Gemini API request failed with status: ${response.status}`);
                }

                const result = await response.json();
                console.log('Gemini API raw result:', result); // Log the raw result object

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const jsonString = result.candidates[0].content.parts[0].text;
                    console.log('Gemini API raw JSON string:', jsonString); // Log the raw JSON string before cleaning
                    // Attempt to clean and parse the JSON.
                    const cleanedJsonString = jsonString.replace(/```json\n|\n```/g, '').trim();
                    console.log('Gemini API cleaned JSON string:', cleanedJsonString); // Log the cleaned JSON string
                    return JSON.parse(cleanedJsonString);
                } else {
                    console.warn("Gemini API returned no candidates or content.", result);
                    return { playlistTitle: "Suggested Playlist", songs: [] };
                }
            } catch (error) {
                // Log the full error object for comprehensive debugging
                console.error("Error calling Gemini API for suggestions (full error):", error);
                throw new Error("Failed to get song suggestions using AI.");
            }
        }

        /**
         * Uses Gemini API to generate a short summary/description for a playlist.
         * @param {string} playlistTitle The title of the playlist.
         * @param {Array<Object>} songs The list of selected songs in the playlist.
         * @returns {Promise<string>} A generated description for the playlist.
         */
        async function generatePlaylistDescription(playlistTitle, songs) {
            const trackList = songs.map(s => `${s.title} by ${s.artist || 'Unknown Artist'}`).join('\n');
            const chatHistory = [];
            const prompt = `Generate a short (1-2 sentences) creative description for a Spotify playlist titled "${playlistTitle}" which contains the following songs:
            ${trackList}

            Do not include the playlist title in the response. Focus purely on describing the vibe or purpose of the playlist based on its contents.`;

            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory }; // No specific schema needed, just plain text response

            const apiKey = ""; // Canvas will provide this API key at runtime.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Gemini API summary request failed:', response.status, response.statusText, errorText);
                    throw new Error(`Gemini API summary request failed with status: ${response.status}`);
                }

                const result = await response.json();
                console.log('Gemini API summary raw result:', result);

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text.trim();
                } else {
                    console.warn("Gemini API returned no candidates or content for summary.", result);
                    return "No summary could be generated for this playlist.";
                }
            } catch (error) {
                console.error("Error calling Gemini API for summary:", error);
                throw new Error("Failed to generate playlist summary.");
            }
        }


        /**
         * Handles the Spotify authentication callback.
         */
        async function handleSpotifyCallback() {
            // Check for code in query parameters first (standard for PKCE)
            const urlParams = new URLSearchParams(window.location.search);
            let code = urlParams.get('code');

            // Fallback to hash if no code in query (for older or specific flows)
            if (!code && window.location.hash) {
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                code = hashParams.get('code');
            }

            if (code) {
                currentView = 'auth_pending';
                updateView();
                isLoading = true;
                try {
                    await SpotifyAuth.getAccessToken(code);
                    spotifyProfile = await SpotifyAPI.getCurrentUserProfile();
                    showMessageBox(`Logged in as ${spotifyProfile.display_name}!`, 'success');
                    // Clean URL by removing query and hash parameters
                    window.history.replaceState({}, document.title, window.location.pathname);
                    currentView = 'input'; // Go to input page after successful auth
                } catch (err) {
                    console.error('Spotify Auth Error:', err);
                    showMessageBox(`Spotify Login Failed: ${err.message}. Please try again.`, 'error');
                    currentView = 'input'; // Fallback to input
                } finally {
                    isLoading = false;
                    updateView();
                }
            } else {
                // Try to get token from localStorage if user visits directly
                const token = localStorage.getItem('spotify_access_token');
                if (token) {
                    try {
                        spotifyProfile = await SpotifyAPI.getCurrentUserProfile();
                        spotifyDisplayNameEl.textContent = spotifyProfile.display_name;
                        // Initial view is input if already logged in
                        currentView = 'input';
                    } catch (err) {
                        console.error('Error fetching Spotify profile:', err);
                        // If token is invalid, clear it
                        localStorage.removeItem('spotify_access_token');
                        localStorage.removeItem('spotify_token_expires_at');
                        localStorage.removeItem('spotify_refresh_token');
                        spotifyProfile = null; // Force login view
                        currentView = 'input'; // Ensures we revert to input view and then to login
                    } finally {
                         updateView(); // Always update view after checking token
                    }
                } else {
                    // If no token and no code, show login view
                    currentView = 'input'; // Default to input view which will show login button if not logged in
                    updateView();
                }
            }
        }

        /**
         * Initiates the Spotify login process.
         */
        loginSpotifyBtn.addEventListener('click', async () => {
            isLoading = true;
            updateLoadingState(loginSpotifyBtn, 'Login with Spotify', 'Logging in');
            try {
                await SpotifyAuth.redirectToAuthCodeFlow();
            } catch(err) {
                showMessageBox(`Failed to initiate Spotify login: ${err.message}`, 'error');
                isLoading = false;
                updateLoadingState(loginSpotifyBtn, 'Login with Spotify');
            }
        });

        /**
         * Gets AI suggestions based on playlist description and fetches Spotify search results.
         */
        getSuggestionsBtn.addEventListener('click', async () => {
            playlistDescription = playlistDescriptionTextarea.value.trim();

            if (!playlistDescription) {
                showMessageBox('Please enter a description for your playlist.', 'error');
                return;
            }

            isLoading = true;
            updateLoadingState(getSuggestionsBtn, 'Get AI Song Suggestions', 'Getting Suggestions');
            messageBoxContainer.innerHTML = ''; // Clear previous messages
            try {
                const aiResponse = await getAiSuggestedPlaylist(playlistDescription);
                playlistTitle = aiResponse.playlistTitle; // Use AI suggested title
                const aiSuggestedSongs = aiResponse.songs;

                const songsWithSpotify = await Promise.all(aiSuggestedSongs.map(async (song) => {
                    const query = song.artist ? `${song.title} ${song.artist}` : song.title;
                    try {
                        const spotifyResults = await SpotifyAPI.searchTracks(query);
                        return {
                            ...song,
                            spotifyResults: spotifyResults.tracks.items,
                            selectedTrack: spotifyResults.tracks.items.length > 0 ? spotifyResults.tracks.items[0] : null // Pre-select first result
                        };
                    } catch (searchErr) {
                        console.error(`Error searching Spotify for "${query}":`, searchErr);
                        return { ...song, spotifyResults: [], selectedTrack: null };
                    }
                }));
                parsedSongs = songsWithSpotify;
                currentView = 'preview'; // Move to preview stage
                stopPreview(); // Ensure no audio plays when moving views
            } catch(err) {
                console.error('Error getting AI suggestions or parsing songs:', err);
                showMessageBox(`Error getting suggestions: ${err.message}. Please try again.`, 'error');
            } finally {
                isLoading = false;
                updateView();
            }
        });

        /**
         * Handles selection of a specific Spotify track for a parsed song entry.
         * @param {number} index The index of the song in the `parsedSongs` array.
         * @param {object} track The selected Spotify track object.
         */
        function handleTrackSelection(index, track) {
            parsedSongs[index].selectedTrack = track;
            renderParsedSongsList(); // Re-render to update UI
            // Also update the create button's disabled state
            createPlaylistBtn.disabled = parsedSongs.filter(s => s.selectedTrack).length === 0 || isLoading;
        }

        /**
         * Removes a song from the preview list.
         * @param {number} index The index of the song to remove.
         */
        function handleRemoveSong(index) {
            parsedSongs = parsedSongs.filter((_, i) => i !== index);
            renderParsedSongsList(); // Re-render to update UI
            // Also update the create button's disabled state
            createPlaylistBtn.disabled = parsedSongs.filter(s => s.selectedTrack).length === 0 || isLoading;
        }

        /**
         * Creates the Spotify playlist with selected tracks.
         */
        createPlaylistBtn.addEventListener('click', async () => {
            if (!spotifyProfile) {
                showMessageBox('Please log in with Spotify first.', 'error');
                return;
            }

            isLoading = true;
            updateLoadingState(createPlaylistBtn, 'Create Playlist', 'Creating Playlist');
            messageBoxContainer.innerHTML = ''; // Clear previous messages
            try {
                const selectedTrackUris = parsedSongs
                    .filter(song => song.selectedTrack && song.selectedTrack.uri)
                    .map(song => song.selectedTrack.uri);

                if (selectedTrackUris.length === 0) {
                    showMessageBox('No songs selected to add to the playlist. Please select some tracks or go back to change description.', 'info');
                    isLoading = false;
                    updateLoadingState(createPlaylistBtn, 'Create Playlist');
                    return;
                }

                const playlist = await SpotifyAPI.createPlaylist(
                    spotifyProfile.id,
                    playlistTitle,
                    `Playlist created by AI-Powered Spotify Playlist Maker` // Updated description
                );

                // Add tracks to the newly created playlist in batches if needed (Spotify API limit is 100 tracks per request)
                const chunkSize = 100;
                for (let i = 0; i < selectedTrackUris.length; i += chunkSize) {
                    const chunk = selectedTrackUris.slice(i, i + chunkSize);
                    await SpotifyAPI.addTracksToPlaylist(playlist.id, chunk);
                }

                newPlaylistUrl = playlist.external_urls.spotify;
                currentView = 'created'; // Go to confirmation page
                // Clear inputs for a new playlist
                playlistDescription = ''; // Clear description
                playlistTitle = '';
                parsedSongs = [];
                stopPreview(); // Stop any playing audio
            } catch (err) {
                console.error('Error creating playlist:', err);
                showMessageBox(`Failed to create playlist: ${err.message}. Please ensure you are logged in and have permission.`, 'error');
            } finally {
                isLoading = false;
                updateView();
            }
        });

        /**
         * Plays a short audio preview of a Spotify track.
         * @param {string} previewUrl The URL of the audio preview.
         * @param {string} trackId The ID of the track.
         */
        function playPreview(previewUrl, trackId) {
            // Stop any currently playing audio
            if (audioPlayer.src && !audioPlayer.paused) {
                audioPlayer.pause();
                audioPlayer.src = '';
                playingTrackId = null;
            }

            // If the same track is clicked again, stop it. Otherwise, play the new one.
            if (previewUrl && playingTrackId !== trackId) {
                audioPlayer.src = previewUrl;
                audioPlayer.volume = 0.5; // Set a default volume for previews
                audioPlayer.play().catch(e => console.error("Error playing audio:", e));
                playingTrackId = trackId;
                // Reset playing state when audio ends or errors
                audioPlayer.onended = () => { playingTrackId = null; renderParsedSongsList(); };
                audioPlayer.onerror = () => {
                    console.error("Audio playback error.");
                    playingTrackId = null;
                    renderParsedSongsList();
                };
            } else if (playingTrackId === trackId) {
                 // If already playing this track, stop it
                 stopPreview();
            }
            renderParsedSongsList(); // Re-render to update play/pause button state
        }

        /**
         * Stops the currently playing audio preview.
         */
        function stopPreview() {
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.src = '';
                playingTrackId = null;
            }
            renderParsedSongsList(); // Re-render to update play/pause button state
        }

        // --- New Feature: Generate Playlist Summary ---
        generateSummaryBtn.addEventListener('click', async () => {
            if (!playlistTitle || parsedSongs.length === 0) {
                showMessageBox('Cannot generate summary: playlist title or songs are missing.', 'info');
                return;
            }

            isLoading = true;
            updateLoadingState(generateSummaryBtn, 'Generate Playlist Summary ✨', 'Generating Summary');
            aiPlaylistSummaryContainer.classList.add('hidden'); // Hide previous summary
            aiPlaylistSummaryEl.textContent = ''; // Clear previous summary
            messageBoxContainer.innerHTML = ''; // Clear previous messages

            try {
                // To generate a summary, we need the *original* parsed songs from the preview step,
                // as `parsedSongs` is reset after playlist creation.
                // For this example, we'll use `parsedSongs` assuming it still holds the final selection,
                // but in a real app, you might want to store the selected songs more persistently
                // or fetch them again from Spotify.
                // For now, let's assume `parsedSongs` still has the list of tracks chosen before playlist creation.
                const summary = await generatePlaylistDescription(createdPlaylistTitleEl.textContent, parsedSongs);
                aiPlaylistSummary = summary;
                aiPlaylistSummaryEl.textContent = summary;
                aiPlaylistSummaryContainer.classList.remove('hidden');
            } catch (err) {
                console.error('Error generating playlist summary:', err);
                showMessageBox(`Failed to generate summary: ${err.message}.`, 'error');
            } finally {
                isLoading = false;
                updateLoadingState(generateSummaryBtn, 'Generate Playlist Summary ✨');
            }
        });


        /**
         * Resets the application to the initial input state, clearing all data.
         */
        function resetApp() {
            currentView = 'input';
            playlistDescription = '';
            playlistTitle = '';
            parsedSongs = [];
            isLoading = false;
            spotifyProfile = null; // Re-authenticate is needed
            newPlaylistUrl = '';
            aiPlaylistSummary = ''; // Clear summary on reset
            stopPreview(); // Stop any playing audio
            messageBoxContainer.innerHTML = ''; // Clear any lingering messages
            handleSpotifyCallback(); // Re-initialize auth flow to check for existing token
        }

        // --- Event Listeners for Navigation Buttons ---
        backToDescriptionBtn.addEventListener('click', () => {
            currentView = 'input';
            stopPreview();
            updateView();
        });

        createAnotherPlaylistBtn.addEventListener('click', () => {
            resetApp();
        });


        // --- Initial Load ---
        window.addEventListener('load', () => {
            handleSpotifyCallback(); // Check for Spotify callback or existing token
            // Initial view update will be triggered by handleSpotifyCallback's logic
        });
    </script>
</body>
</html>
